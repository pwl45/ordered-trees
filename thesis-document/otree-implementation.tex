This chapter provides two implementations of the Gray code given in \ref{chap:otree-graycode}.  
Section \ref{sec:relationship-loopless} discusses this chapter's algorithm in the context of other related results.  Section \ref{sec:otree-link} provides an implementation using a linked-list like structure for storing children.  Secion \ref{sec:otree-arr} provides an implementation using an array structure to store children.  


\section{Relationship to Previous Results}\label{sec:relationship-loopless}
The algorithms in sections \ref{sec:otree-link} and \ref{sec:otree-arr} both generate ordered trees \emph{looplessly}, meaning that each tree is generated in worst-case constant time.  This is faster than other algorithms for generating ordered trees which take constant amortized time \cite{parque2021efficient} \cite{er1985lexotrees} \cite{zaks1980lexotrees} \cite{skarbek1988pointerotrees}. Parque and Miyashita present a constant amortized time algorithm for generating ordererd trees, claiming that it operates ``with utmost efficiency'' \cite{parque2021efficient}.  Our algorithm operates in worst-case constant time per tree, which is faster. To borrow Parque and Miyashita's terminology, perhaps we should say that our algorithm operates with \emph{utmoster} efficiency. 

Taken in conjunction with Ruskey and Williams's algorithms for Dyck words and binary trees, this algorithm completes a trio of loopless cool-lex algorithms for enumerating the three foremost Catalan structures.  
Additionally, like the cool-lex algorithm for binary trees, this algorithm generates ordered trees stored as pointer structures.  This contrasts from other efficient Gray codes for enumerating ordered trees, which use either bit-strings or integer sequences to represent ordered trees \cite{parque2021efficient} \cite{zaks1980lexotrees} \cite{er1985lexotrees} as representations of ordered trees.  Skarbek's 1988 paper \emph{Generating Ordered Trees} gives a constant amortized time algorithm for generating ordered trees stored as pointer structures and is therefore a notable exception to this \cite{skarbek1988pointerotrees}.
Generating ordered trees via a pointer structure facilitates the practical %TODO: word?
use of the trees generated by this algorithm, as a translation step between an alternative representation and a tree structure to traverse the tree is not necessary.

% The first implementation uses a linked structure for the nodes, where an ordered tree node stores pointers to its leftmost child and its right sibling.  Therefore, to access a node's 3rd child, one would use \verb+node->first->right->right+.
% This has the advantages of space efficiency and $O(1)$ appending and prepending to a node's list of children, but the disadvantage of requiring $O(k)$ time to access a node's $k\thh$ child. 

% Figure \ref{fig:otreeStarter} gives struct definitions for both tree representations and an implementation of $\pull{A}{B}$ for each.





The algorithms for both the linked-list and array representations of ordered trees take the following approach.  They begin by creating an initial tree $\tree{T}_1$ with $n+1$ nodes such that $\dyck{\tree{T}_1}=101^{n-1}0^{n-1}$.  This tree can be generated by creating a path with $n+1$ nodes and executing $\pull{root,P}$ where $P$ is the parent of the path's leaf. Both algorithms then repeatedly apply the successor rule from equation \ref{eq:otreeRule}.  The algorithms keep track of $O$ using the observation if $O$ has at least one child before shifting, the new first branching is between $O$ and $O$'s second child after shifting.  If $O$ has no children before shifting, the new first branching is between $P$ and $P$'s second child after shifting. Figures \ref{fig:otreeCode} and \ref{fig:aotreeCode} provide pseudocode and a C implementation for this algorithm using each tree representation. 

% TODO NEW: initial tree

\section{Storing Children in a Linked List}\label{sec:otree-link}
The implementation in this section linked structure to store a node's children, where an ordered tree node stores pointers to its first (leftmost) child and its right sibling.  Therefore, to access a node's 3rd child, one would use \verb+node->first->right->right+.
This has the advantages of space efficiency and $O(1)$ appending and prepending to a node's list of children, but the disadvantage of requiring $O(k)$ time to access a node's $k\thh$ child. 

Figure \ref{fig:otreestarter-link} provides the C struct definition for this ordered tree definition as well as an implementation of $\pull{A}{B}$ and a helper function for accessing a node's $k\thh$ child. 

\begin{figure}[H]
    % \begin{subfigure}[t]{.5 \textwidth}
	\begin{center}

	    \begin{Verbatim}
typedef struct node {
  struct node* parent;
  struct node* first;
  struct node* right;
} node;

void pull(node *A, node *B){ 
  // A pulls B's first child
  node *pulled = B->first;
  B->first = pulled->right;
  pulled->right = A->first;
  A->first = pulled;
  pulled->parent = A;
}

node* kthchild(node* parent, int k){
  node* curr=parent->first;
  for(int i = 1; i < k; i++){
    curr=curr->right;
  }
  return curr;
}
\end{Verbatim}

    \cprotect\caption{Struct definitions and implementations for $\pull{A}{B}$ and accessing a $k\thh$ child for an link-based ordered tree structure.}
\label{fig:otreestarter-link}
	\end{center}
\end{figure}

    The algorithm in Figure \ref{fig:otreeCode} uses a while loop with two if statements per successor to evaulate the cases in \eqref{eq:otreeRule}.  The while loop evaluates if there is a first branching: if \verb+NULL+ is assigned to $O$, then there is no first branching, and the order is complete.  The first if statement evaluates whether $O$ has at least 1 child: $O$'s first child is not \verb+NULL+ if and only if O has at least 1 child. The second if statement evaluates whether $P$ is the root of the tree.  The algorithm executes $\pull{O}{P}$ if $O$ has at least child or $P$ is the root of the tree.  Otherwise, it executes $\pull{G}{P}$ and $\pull{root}{P}$ 


\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{.49 \textwidth}
	\begin{center}
	    \begin{algorithm}[H] % What does the H do? it makes it work.
	    \begin{algorithmic}
    \Function{cool-ordered-trees}{$t$}
        % \vspace{0.75em}
        \LineComment{Generate initial tree} % TODO
	\State $O\gets root.first$
	\State \visit{root}
        \While{$O \ne NULL$}
	    \State $P \gets O.parent$
	    \If{$O.first \ne NULL$}
		\State $\pull{O}{P}$
		\State $O \gets O.first.right$
	    \Else
		\If{$P == root$}
		\State $\pull{O}{P}$
		\Else
		\State $\pull{O}{P}$
		\State $\pull{root}{P}$
		\EndIf
		\State $O \gets O.right$
	    \EndIf
	\State \visit{root}
        \EndWhile
    \EndFunction
	    \end{algorithmic}
    \caption*{Generate all ordered trees with $t+1$ nodes}
	\end{algorithm}
	\end{center}
	% \caption{Pseudoc}
	\label{fig:}
    \end{subfigure}
    \begin{subfigure}[t]{.5 \textwidth}
	\begin{center}
	    \vspace{.9em} % fun alignment
	    % \vspace{2.1em} % fun alignment
\begin{Verbatim}[commandchars=\\\[\]]

void coolOtree(int n) {
  node* root = get_initial_tree(n);
  node* o=root->first->right;
  visit(root);
  while (o) {
    p=o->parent;
    if (o->first) {
      pull(o,p);
      o = o->first->right;
    } else {
      if (p == root) {
        pull(o,p);
      } else {
        pull(p->parent,p);
        pull(root,p);
      }
      o = o->right;
    }
    visit(root);
  }
}

\end{Verbatim}
	\end{center}
	% \caption{ $C$ implementation of coolOtree} 
	\label{fig:}
    \end{subfigure}
    % TODO: change bit colors
    \cprotect\caption{Pseudocode and C implementation for linked-list tree representation.}
    \label{fig:otreeCode}
\end{figure}

\section{Storing Children in an Array}\label{sec:otree-arr}
The second implementation uses an array-like approach to storing children.  This has the advantage of $O(1)$ access time for all children but the disadvantage of either requiring $O(n)$ space for each node or the additional cost of resizing arrays.  Each node also stores a counter for its number of children and a number keeping track of the maximum amount of children it can store (before requiring reallocation)).  This implementation stores the list of children ``backwards,'' so to access a node's $k\thh$ child, one would use \verb_node->children[(node->nch)-k+1]_.  Each \verb+node->children[0]+ is set to and kept as \verb+NULL+ for a null-termination like effect that is useful in the algorithm.  

Figure \ref{fig:otreestarter-arr} provides the C struct definition for this ordered tree definition as well as an implementation of $\pull{A}{B}$ and a helper function for accessing a node's $k\thh$ child. Figure \ref{fig:otreeCode}
    \begin{figure}
    % \end{subfigure}
    % \begin{subfigure}[t]{.5 \textwidth}
	\begin{center}

	    \begin{Verbatim}
typedef struct arraynode {
    int nch; 
    int maxch;
    struct arraynode* parent;
    struct arraynode** children;
} anode;

void apull(anode* A, anode* B){ 
    //A pulls B's first child
    anode* pulled = B->children[B->nch--];
    A->children[++(A->nch)]=pulled;
    pulled->parent=A;
}

anode* kthchild(anode* parent, int k){
  return parent->children[parent->nch-k+1];
}
	    \end{Verbatim}
	\end{center}
    % \end{subfigure}

    % TODO: change bit colors
    \cprotect\caption{Struct definitions and implementations for $\pull{A}{B}$ and accessing a $k\thh$ child for an array-based ordered tree structure.}
    \label{fig:otreestarter-arr}
\end{figure}

\begin{figure}
    \centering
    \begin{subfigure}[t]{.49 \textwidth}
	\begin{center}
	    \begin{algorithm}[H] % What does the H do? it makes it work.
	    \begin{algorithmic}
    \Function{cool-ordered-trees}{$n$}
        % \vspace{0.75em}
        \LineComment{Generate initial tree} % TODO
		\State $O\gets \kthchild{root}{2}$
	\State \visit{root}
        \While{$O \ne NULL$}
	    \State $P \gets O.parent$
	    \If{$O.nch > 0$}
		\State $\pull{O}{P}$
		\State $O \gets \kthchild{O}{2}$
	    \Else
		\If{$P == root$}
		\State $\pull{O}{P}$
		\Else
		\State $\pull{P.parent,P}$
		\State $\pull{root,P}$
		\EndIf
		\State $O \gets \kthchild{O.parent}{2}$
	    \EndIf
	\State \visit{root}
        \EndWhile
    \EndFunction
	    \end{algorithmic}
    \caption*{Generate all ordered trees with $n+1$ nodes}
	\end{algorithm}
	\end{center}
	% \caption{Pseudoc}
	\label{fig:}
    \end{subfigure}
    \begin{subfigure}[t]{.5 \textwidth}
	\begin{center}
	    \vspace{.9em} % fun alignment
	    % \vspace{2.1em} % fun alignment
\begin{Verbatim}[]

void coolAOtree(int t, void (*visit)(anode*)){
  anode* root = get_initial_atree(t);
  anode *p, *o=kthchild(root,2);
  visit(root);
  while(o){
    p = o->parent;
    if(o->nch){
      apull(o,p);
      o=kthchild(o,2);
    }else{
      if(p == root){
	apull(o,p);
      }else{
	apull(p->parent,p);
	apull(root,p);
      }
      o=kthchild(o->parent,2);
    }
    visit(root);
  }
}

\end{Verbatim}
	\end{center}
	% \caption{ $C$ implementation of coolOtree} 
	\label{fig:}
    \end{subfigure}
    % TODO: change bit colors
    \cprotect\caption{Pseudocode and C implementation for array-based tree representation.}
    \label{fig:aotreeCode}
\end{figure}
