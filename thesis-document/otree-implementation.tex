This chapter provides two implementations of the Gray code in \ref{chap:otree-graycode}.  The first implementation uses a linked structure for the nodes, where an ordered tree node stores pointers to its leftmost child and its right sibling.  Therefore, to access a node's 3rd child, one would use \verb+node->first->right->right+.
This has the advantages of space efficiency and $O(1)$ appending and prepending to a node's list of children, but the disadvantage of requiring $O(k)$ time to access a node's $k\thh$ child. 

The second implementation uses an array-like approach to storing children.  This has the advantage of $O(1)$ access time for all children but the disadvantage of either requiring $O(n)$ space for each node or the additional cost of resizing arrays.  Each node also stores a counter for its number of children and a number keeping track of the maximum amount of children it can store (before requiring reallocation)).  This implementation stores the list of children ``backwards,'' so to access a node's $k\thh$ child, one would use \verb_node->children[(node->nch)-k+1]_.  Each \verb+node->children[0]+ is set to and kept as \verb+NULL+ for a null-termination like effect that is useful in the algorithm.  Figure \ref{fig:otreeStarter} gives struct definitions for both tree representations and an implementation of $\pull{A}{B}$ for each.

% TODO NEW: initial tree
\begin{figure}[H]
    \begin{subfigure}[t]{.5 \textwidth}
	\begin{center}

	    \begin{Verbatim}
typedef struct node {
  struct node* parent;
  struct node* first;
  struct node* right;
} node;

void pull(node *A, node *B){ 
  // A pulls B's first child
  node *pulled = B->first;
  B->first = pulled->right;
  pulled->right = A->first;
  A->first = pulled;
  pulled->parent = A;
}

node* kthchild(node* parent, int k){
  node* curr=parent->first;
  for(int i = 1; i < k; i++){
    curr=curr->right;
  }
  return curr;
}
\end{Verbatim}
	\end{center}
	\label{fig:}
    \end{subfigure}
    \begin{subfigure}[t]{.5 \textwidth}
	\begin{center}

	    \begin{Verbatim}
typedef struct arraynode {
    int nch; 
    int maxch;
    struct arraynode* parent;
    struct arraynode** children;
} anode;

void apull(anode* A, anode* B){ 
    //A pulls B's first child
    anode* pulled = B->children[B->nch--];
    A->children[++(A->nch)]=pulled;
    pulled->parent=A;
}

anode* kthchild(anode* parent, int k){
  return parent->children[parent->nch-k+1];
}
	    \end{Verbatim}
	\end{center}
	\label{fig:}
    \end{subfigure}

    % TODO: change bit colors
    \cprotect\caption{Struct definitions and implementations for $\pull{A}{B}$ and accessing a $k\thh$ child for each tree representation.}
    \label{fig:otreeStarter}
\end{figure}


The algorithms for both the linked-list and array representations of ordered trees take the following approach.  They begin by creating an initial tree $\tree{T}_1$ with $n+1$ nodes such that $\dyck{\tree{T}_1}=101^{n}0^{n}$.  This tree can be generated by creating a path with $n+1$ nodes and executing $\pull{root,P}$ where $P$ is the parent of the path's leaf. Both algorithms then repeatedly apply the successor rule from equation \ref{eq:otreeRule}.  The algorithms keep track of $O$ using the observation if $O$ has at least one child before shifting, the new first branching is between $O$ and $O$'s second child after shifting.  If $O$ has no children before shifting, the new first branching is between $P$ and $P$'s second child after shifting. Figures \ref{fig:otreeCode} and \ref{fig:aotreeCode} provide pseudocode and a C implemmentation for this algorithm using each tree representation. 
% \begin{figure}
%     \centering
% \begin{tikzpicture}[every tree node/.style={draw,circle},sibling distance=10pt, level distance=40pt]
% \tikzset{edge from parent/.style={draw, edge from parent path=
%     {(\tikzparentnode) -- (\tikzchildnode)}}}
%     \Tree [.{} [.{} ] ] 
% \end{tikzpicture} \hspace{1.5em}
% \begin{tikzpicture}[every tree node/.style={draw,circle},sibling distance=10pt, level distance=40pt]
% \tikzset{edge from parent/.style={draw, edge from parent path=
%     {(\tikzparentnode) -- (\tikzchildnode)}}}
%     \Tree [.{} [.{} ] [.{} ] ] 
% \end{tikzpicture}\hspace{1.5em}
% \begin{tikzpicture}[every tree node/.style={draw,circle},sibling distance=10pt, level distance=40pt]
% \tikzset{edge from parent/.style={draw, edge from parent path=
%     {(\tikzparentnode) -- (\tikzchildnode)}}}
%     \Tree [.{} [.{} ] [.{} [.{} ] ] ] 
% \end{tikzpicture}\hspace{1.5em}
% \begin{tikzpicture}[every tree node/.style={draw,circle},sibling distance=10pt, level distance=40pt]
% \tikzset{edge from parent/.style={draw, edge from parent path=
%     {(\tikzparentnode) -- (\tikzchildnode)}}}
%     \Tree [.{} [.{} ] [.{} [.{} [.{} ] ] ] ] 
% \end{tikzpicture}

%     \cprotect\caption{The initial trees returned by \verb$get_initial_tree$ in \verb$coolOtree$ with $t=1,2,3,$ and $4$ \\
%     Note the convenient feature that for each tree, O is equal to \verb$root->first->right$
%     }
%     \label{exampleotree}
% \end{figure}



% TODO NEW: initial tree
\begin{figure}
    \centering
    \begin{subfigure}[t]{.49 \textwidth}
	\begin{center}
	    \begin{algorithm}[H] % What does the H do? it makes it work.
	    \begin{algorithmic}
    \Function{cool-ordered-trees}{$t$}
        % \vspace{0.75em}
        \LineComment{Generate initial tree} % TODO
	\State $O\gets root.first$
	\State \visit{root}
        \While{$O \ne NULL$}
	    \State $P \gets O.parent$
	    \If{$O.first \ne NULL$}
		\State $\pull{O}{P}$
		\State $O \gets O.first.right$
	    \Else
		\If{$P == root$}
		\State $\pull{O}{P}$
		\Else
		\State $\pull{O}{P}$
		\State $\pull{root}{P}$
		\EndIf
		\State $O \gets O.right$
	    \EndIf
	\State \visit{root}
        \EndWhile
    \EndFunction
	    \end{algorithmic}
    \caption*{Generate all ordered trees with $t+1$ nodes}
	\end{algorithm}
	\end{center}
	% \caption{Pseudoc}
	\label{fig:}
    \end{subfigure}
    \begin{subfigure}[t]{.5 \textwidth}
	\begin{center}
	    \vspace{.9em} % fun alignment
	    % \vspace{2.1em} % fun alignment
\begin{Verbatim}[commandchars=\\\[\]]

void coolOtree(int n) {
  node* root = get_initial_tree(n);
  node* o=root->first->right;
  visit(root);
  while (o) {
    p=o->parent;
    if (o->first) {
      pull(o,p);
      o = o->first->right;
    } else {
      if (p == root) {
        pull(o,p);
      } else {
        pull(p->parent,p);
        pull(root,p);
      }
      o = o->right;
    }
    visit(root);
  }
}

\end{Verbatim}
	\end{center}
	% \caption{ $C$ implementation of coolOtree} 
	\label{fig:}
    \end{subfigure}
    % TODO: change bit colors
    \cprotect\caption{Pseudocode and C implementation for linked-list tree representation.}
    \label{fig:otreeCode}
\end{figure}

\begin{figure}
    \centering
    \begin{subfigure}[t]{.49 \textwidth}
	\begin{center}
	    \begin{algorithm}[H] % What does the H do? it makes it work.
	    \begin{algorithmic}
    \Function{cool-ordered-trees}{$n$}
        % \vspace{0.75em}
        \LineComment{Generate initial tree} % TODO
		\State $O\gets \kthchild{root}{2}$
	\State \visit{root}
        \While{$O \ne NULL$}
	    \State $P \gets O.parent$
	    \If{$O.nch > 0$}
		\State $\pull{O}{P}$
		\State $O \gets \kthchild{O}{2}$
	    \Else
		\If{$P == root$}
		\State $\pull{O}{P}$
		\Else
		\State $\pull{P.parent,P}$
		\State $\pull{root,P}$
		\EndIf
		\State $O \gets \kthchild{O.parent}{2}$
	    \EndIf
	\State \visit{root}
        \EndWhile
    \EndFunction
	    \end{algorithmic}
    \caption*{Generate all ordered trees with $n+1$ nodes}
	\end{algorithm}
	\end{center}
	% \caption{Pseudoc}
	\label{fig:}
    \end{subfigure}
    \begin{subfigure}[t]{.5 \textwidth}
	\begin{center}
	    \vspace{.9em} % fun alignment
	    % \vspace{2.1em} % fun alignment
\begin{Verbatim}[]

void coolAOtree(int t, void (*visit)(anode*)){
  anode* root = get_initial_atree(t);
  anode *p, *o=kthchild(root,2);
  visit(root);
  while(o){
    p = o->parent;
    if(o->nch){ //if o has a child, shift 1
      apull(o,p);
      o=kthchild(o,2);
    }else{
      if(p == root){ //if the string is tight, shift a 1
	apull(o,p);
      }else{ //if the string isn't tight, shift a zero
	apull(p->parent,p);
	apull(root,p);
      }
      o=kthchild(o->parent,2);
    }
    visit(root);
  }
}

\end{Verbatim}
	\end{center}
	% \caption{ $C$ implementation of coolOtree} 
	\label{fig:}
    \end{subfigure}
    % TODO: change bit colors
    \cprotect\caption{Pseudocode and C implementation for array-based tree representation.}
    \label{fig:aotreeCode}
\end{figure}
