This chapter will give background information on cool-lex order and the sets it has been used to enumerate.  
\section{$(s,t)$ Combinations: Fixed-Weight Binary Strings} \label{sec:coolCombo}
Generating all binary strings with $s$ zeroes and $t$ ones is often referred to as $(s,t)$ combinations, since each string can be used to represent a choice of $t$ elements from a set of size of $s+t$.  The cool-lex successor rule for generating all fixed-weight binary strings was given by Aaron Williams in his Ph. D thesis and is as follows \cite{williams2009shift}:

 Let $\alpha$ be a binary string of length $n$.

 Let $y$ be the position of the leftmost zero in $\alpha$ and $x$ be the position of the leftmost 1 in $\alpha$ such that $x > y$.  If there is no such 1, let $x=n$.

 Note that $\alpha_1...\alpha_{x-1}$ is the non-increasing prefix of $\alpha$.

 Let $\leftshift[\alpha]{i}$ be a simplified version of the left shift function defined in equation \ref{eq:leftdef}:  $\leftshift[\alpha]{i}$ shifts the $i\thh$ symbol of $\alpha$ into the first position.  Thus, $\leftshift[\alpha]{i}=\lshiftindex[\alpha]{1}{i}$.

% function that shifts the $i\thh$ bit of $\alpha$ into the rotates the first i bits of a string $\alpha$ right circularly by one.

% More formally, 
%  $\leftshift[\alpha]{i}=\alpha_2,\alpha_3,...,\alpha_i,\alpha_1,\alpha_{i-1},\alpha_{i+1},\alpha_{i+2},...,\alpha_{2n}$
\begin{equation*}
    \overleftarrow{\text{cool}}(\alpha) = \begin{cases}
	\leftshift[\alpha]{x} & \text{if $\alpha_{x+1}=1$}\\
	\leftshift[\alpha]{x+1} & otherwise\\
\end{cases}
\end{equation*}

Figure \ref{subfig:coolcombo} demonstrates this rule being used to enumerate combinations of 4 zeroes and 2 ones.


The restriction that the first $x$ symbols of the string are non-increasing allows for simplification of the left shift operation.  Note that $\alpha_1...\alpha_{x-1}$ must be exactly $1^{y-1}0^{x-y}$, where exponentiation denotes repeated symbols.  Because of this, the two left-shift operations can be replaced with can be replaced with either one or two symbol transpositions.

 Let $\transpose{\alpha}{i}{j}$ with $1 \le i \le j \le n$ be a function that swaps $\alpha_i$ an $\alpha_j$.  More formally, $\transpose{\alpha}{i}{j}=\alpha_1,\alpha_2,\dots,\alpha_{i-1},\alpha_{j}\alpha_{i+1}\dots \alpha_{j-1}\alpha_i \alpha_{j+1}\dots \alpha_n$
The left-shift rule can be re-stated as follows:

\begin{equation*}
    \overleftarrow{\text{cool}}(\alpha) = \begin{cases}
	\transpose{\alpha}{y}{x} & \text{if $\alpha_{x+1}=1$}\\
	\transpose{\transpose{\alpha}{y}{x}}{1}{x+1} & otherwise\\
\end{cases}
\end{equation*}


\begin{figure}
    \begin{center}
	\begin{subfigure}[]{.25\textwidth}
            \begin{center}
\begin{Verbatim}[commandchars=\\\{\}]
[0, \textcolor{red}{\underline{1}}, 1, 0, 0, 0]
 |<-|
[1, 0, \textcolor{red}{\underline{1}}, 0, 0, 0]
 |<-------|
[0, \textcolor{red}{\underline{1}}, 0, 1, 0, 0]
 |<----|
[0, 0, \textcolor{red}{\underline{1}}, 1, 0, 0]
 |<----|
[1, 0, 0, \textcolor{red}{\underline{1}}, 0, 0]
 |<----------|
[0, \textcolor{red}{\underline{1}}, 0, 0, 1, 0]
 |<----|
[0, 0, \textcolor{red}{\underline{1}}, 0, 1, 0]
 |<-------|
[0, 0, 0, \textcolor{red}{\underline{1}}, 1, 0]
 |<-------|
[1, 0, 0, 0, \textcolor{red}{\underline{1}}, 0]
 |<-------------|
[0, \textcolor{red}{\underline{1}}, 0, 0, 0, 1]
 |<----|
[0, 0, \textcolor{red}{\underline{1}}, 0, 0, 1]
 |<-------|
[0, 0, 0, \textcolor{red}{\underline{1}}, 0, 1]
 |<----------|
[0, 0, 0, 0, \textcolor{red}{\underline{1}}, 1]
 |<----------|
[1, 0, 0, 0, 0, \textcolor{red}{\underline{1}}]
 |<-------------|
[1, 1, 0, 0, 0, 0]
\end{Verbatim}
            \end{center}
	    \caption{$(s-t)$ combinations with $s=4$ zeroes and $t=2$ ones}
            \label{subfig:coolcombo}
        \end{subfigure}
        \begin{subfigure}[]{.32\textwidth}
            \begin{center}
\begin{Verbatim}[commandchars=\\\{\}]
[1, 0, \textcolor{red}{\underline{1}}, 1, 1, 0, 0, 0]
    |<-|
[1, 1, 0, \textcolor{red}{\underline{1}}, 1, 0, 0, 0]
    |<----|
[1, 1, 1, 0, \textcolor{red}{\underline{1}}, 0, 0, 0]
    |<----------|
[1, 0, \textcolor{red}{\underline{1}}, 1, 0, 1, 0, 0]
    |<-|
[1, 1, 0, \textcolor{red}{\underline{1}}, 0, 1, 0, 0]
    |<-------|
[1, 0, \textcolor{red}{\underline{1}}, 0, 1, 1, 0, 0]
    |<-|
[1, 1, 0, 0, \textcolor{red}{\underline{1}}, 1, 0, 0]
    |<-------|
[1, 1, 1, 0, 0, \textcolor{red}{\underline{1}}, 0, 0]
    |<-------------|
[1, 0, \textcolor{red}{\underline{1}}, 1, 0, 0, 1, 0]
    |<-|
[1, 1, 0, \textcolor{red}{\underline{1}}, 0, 0, 1, 0]
    |<-------|
[1, 0, \textcolor{red}{\underline{1}}, 0, 1, 0, 1, 0]
    |<-|
[1, 1, 0, 0, \textcolor{red}{\underline{1}}, 0, 1, 0]
    |<-------|
[1, 1, 1, 0, 0, 0, \textcolor{red}{\underline{1}}, 0]
    |<-------------|
[1, 1, 1, 1, 0, 0, 0, 0]

\end{Verbatim}
            \end{center}
            \caption{Dyck words of order 4}
            \label{fig:}
        \end{subfigure}
        \begin{subfigure}[]{.15\textwidth}
            \begin{center}
\begin{Verbatim}[commandchars=\\\{\}]
[1, \textcolor{red}{\underline{3}}, 3, 2]
 |<-|
[3, 1, \textcolor{red}{\underline{3}}, 2]
 |<----|
[3, 3, 1, \textcolor{red}{\underline{2}}]
 |<-------|
[2, \textcolor{red}{\underline{3}}, 3, 1]
 |<-|
[3, 2, \textcolor{red}{\underline{3}}, 1]
 |<-------|
[1, \textcolor{red}{\underline{3}}, 2, 3]
 |<-|
[3, 1, \textcolor{red}{\underline{2}}, 3]
 |<----|
[2, \textcolor{red}{\underline{3}}, 1, 3]
 |<----|
[1, \textcolor{red}{\underline{2}}, 3, 3]
 |<-|
[2, 1, \textcolor{red}{\underline{3}}, 3]
 |<----|
[3, 2, 1, \textcolor{red}{\underline{3}}]
 |<-------|
[3, 3, 2, 1]
\end{Verbatim}
            \end{center}
	    \caption{Permutations of the multiset \{1,2,3,3\}}
            \label{fig:lotsofcool}
        \end{subfigure}
\end{center}
\caption{Cool-lex order for $(s,t)$ combinations, Dyck words, and multiset permutations. The symbol immediately following each string's non-increasing prefix, or the \emph{first increase} of each string is highlighted in red.  The arrows beneath each string show the shift that translates each string to its successor.  Note that in all cases, either the first increase or the symbol immediately following it is left-shifted.  For $(s,t)$ combinations and multiset permutations, symbols are always shifted to position 1.  For Dyck words, symbols are always shifted to position 2.}
\label{fig:}
\end{figure}

\section{Cool Lex Order on Dyck Words and Binary Trees}

Ruskey and Williams found the following successor rule for enumerating binary Dyck words, dubbed ``CoolCat" due to its use of a cool-lex order to generate (cat)alan objects \cite{ruskey2008generating}:
We will use $\mathbf{D}_n$ to denote binary Dyck words with $n$ ones and $n$ zeroes.  Note that the length of any string in $\mathbf{D}_n$ is therefore $2n$.

 Let $D \in \mathbf{D}_n$

 Let the $i$th prefix shift of D, denoted by $\preshift{D}{i}$, be a function that rotates the second through $i\thh$ symbols of D one to the right circularly.  More formally, 

 $\preshift{D}{i}=d_1,d_i,d_2,...,d_{i-1},d_{i+1},d_{i+2},...,d_{2n}$

 Note that the prefix shift operation is a special case of the left shift operation defined in $\ref{eq:leftdef}$: $\preshift{D}{i}=\lshiftindex[D]{2}{i}$



 Let $k$ be the index of the 1 in the leftmost $01$ substring in $D$ if it exists and $2n$ if $D$ has no $01$ substring. Note that if $D$ has no $01$ substring, then $D=1^n0^n$.
Furthermore, note that this definition of $k$ is equivalent to the definition of $x$ in \ref{sec:coolCombo}
The successor rule for $D$ is as follows:


\begin{subnumcases}{\coolCat{D} = \label{eq:prefixDyck_simple}}
	% \preshift{D}{2n} & \text{if $D$ has no $01$ substring}\\
	\preshift{D}{k+1} & if $\preshift{D}{k+1} \in \mathbf{D}_n$\\
	\preshift{D}{k} & otherwise
\end{subnumcases}

Ruskey and Williams's algorithm can also enumerate a broader set of strings: The algorithm enumerates any set $\mathbf{D}_{s,t}$ where any $D \in \mathbf{D}_{s,t}$ has s zeroes and t ones and satisfies the constraint that each prefix of D has as many ones as zeroes.  This is slightly broader than the language of Dyck words, as it does not have the requirement that a string have an equal number of ones and zeroes.
We will focus on $\mathbf{D}_n$  languages due to their correspondce with Dyck words and therefore other Catalan objects.

Evaluating whether $\preshift{D}{k+1} \in \mathbf{D}_n$ can be determined by looking at $D_{k+1}$ and the the first $k-1$ symbols of D: 

If $D_{k+1}=1$, then shifting it into the second position is valid.  If $D_{k+1}=0$ and $D$ starts with at least $\frac{k-1}{2}$ ones, then shifting a 0 into the second position will not invalidate the condition that all prefixes of $D$ have at least as many ones as zeroes.   Therefore, the successor rule in \ref{eq:prefixDyck_simple} can be simplified to the following: 

\begin{subnumcases}{\coolCat{D} = \label{eq:prefixDyck}}
    % \preshift{D}{2n} & \text{if $D$ has no $01$ substring} \label{eq:prefixDyck_n}\\
	\preshift{D}{k+1} & $D_{k+1}=1$ or $D$ starts with at least $\lfloor \frac{k-1}{2} \rfloor$ ones \label{eq:prefixDyck_k1}\\
	\preshift{D}{k} & otherwise \label{eq:prefixDyck_k}
\end{subnumcases}


$\preshift{D}{k+1} \in \mathbf{D}_{n} \iff$ $D$ starts with more than $\lfloor \frac{k-1}{2} \rfloor$ ones

Ruskey and Williams provided a loopless pseudocode implementation of CoolCat that utilized this fact to enumerate any $\mathbf{D}_{s,t}$ using at most 2 conditionals per successor \cite{ruskey2008generating}. Using the bijection between Dyck words and binary trees, Ruskey and Williams also showed that their successor rule can be translated to a loopless algorithm for generating all binary trees with $n$ nodes. 

An an additional simplifying observation is that all Dyck words start with 1.  Thus, a conceivable representation of a Dyck word of order $n$ would be a binary string of length $2n-1$, where the $2n-1$ bits of the representation correspond to bits $2$ through $2n$ of the actual Dyck word, and the leading $1$ is implied.  In this case, each $\preshift[D]{i}$ can be replaced with $\leftshift[D]{i}$, each shift now shifts a symbol to index 1. 


With $D$ redefined as above and $k$ defined as before with respect to the updated representation of $D$, the successor rule for Dyck words can be further simplified to the following:

\begin{subnumcases}{\coolCat{D} = \label{eq:prefixDyck_lshift}}
    % \preshift{D}{2n} & \text{if $D$ has no $01$ substring} \label{eq:prefixDyck_n}\\
	\leftshift[D]{k+1} & $D_{k+1}=1$ or $D$ starts with at least $\lfloor \frac{k-2}{2} \rfloor$ ones \label{eq:prefixDyck_k1}\\
	\leftshift[D]{k} & otherwise \label{eq:prefixDyck_k}
\end{subnumcases}

% TODO: binary trees algorithm

Due to its simplicity and efficiency, Don Knuth included the cool-lex algorithm for Dyck words in his 4th volume of \emph{The Art of Computer Programming} and also provided an implementation of it for his theoretical MMIX processor architecture \cite{knuth2015art}. Figure \ref{fig:CoolDycks} gives demonstrates the iteration of coolCat on Dyck words of order $4$.




\begin{figure}[H]
    \centering
    % This figure is temporarily omitted because it is slow
    \begin{tabularx}{0.55\textwidth}{>{\hsize=0.4\hsize}C >{\hsize=0.2\hsize}C >{\hsize=0.2\hsize}C   }
       \thead{Dyck Path} & \thead{Dyck Word} & \thead{Parentheses} \\ \hline 
\DyckTable[3]{2,0,2,2,2,0,0,0} & 10111000 & ()((()))\\
\DyckTable[3]{2,2,0,2,2,0,0,0} & 11011000 & (()(()))\\
\DyckTable[3]{2,2,2,0,2,0,0,0} & 11101000 & ((()()))\\
\DyckTable[2]{2,0,2,2,0,2,0,0} & 10110100 & ()(()())\\
\DyckTable[2]{2,2,0,2,0,2,0,0} & 11010100 & (()()())\\
\DyckTable[2]{2,0,2,0,2,2,0,0} & 10101100 & ()()(())\\
\DyckTable[2]{2,2,0,0,2,2,0,0} & 11001100 & (())(())\\
\DyckTable[3]{2,2,2,0,0,2,0,0} & 11100100 & ((())())\\
\DyckTable[2]{2,0,2,2,0,0,2,0} & 10110010 & ()(())()\\
\DyckTable[2]{2,2,0,2,0,0,2,0} & 11010010 & (()())()\\
\DyckTable[1]{2,0,2,0,2,0,2,0} & 10101010 & ()()()()\\
\DyckTable[2]{2,2,0,0,2,0,2,0} & 11001010 & (())()()\\
\DyckTable[3]{2,2,2,0,0,0,2,0} & 11100010 & ((()))()\\
\DyckTable[4]{2,2,2,2,0,0,0,0} & 11110000 & (((())))\\
    \end{tabularx}
    \caption{The $\C_4=14$ Dyck words of order 4 in cool-lex order}
    \label{fig:CoolDycks}
\end{figure}

\section{Multiset Permutations}

Cool-lex order has also been shown to enumerate multiset permutations via prefix shifts.  The rule given by Williams is as follows \cite{williams2009loopless}:

 Let $\alpha$ be a multiset of length $n$.

 Let $i$ be the maximum value such that $\alpha_{j-1} \ge s_j$ for all $2 \le j \le i$.  In other words, $i$ is the length of the non-increasing prefix of $\alpha$.  

Recall the definition of $\leftshift[\alpha]{i}$ from section $\ref{sec:coolCombo}$

%  Let $\sigma_j(\alpha)$ be a function that shifts the $i\thh$ value of $\alpha$ into the first position, or equivalently rotates the first i elements of $\alpha$ right circularly.  More formally, 

%  $\sigma_j(\alpha)=\alpha_j,\alpha_1,\alpha_1,\dots,\alpha_{j-1},\alpha_{j+1},\dots,\alpha_n $

Then

\begin{equation*}
    \text{nextPerm}(\alpha) = \begin{cases}
	\leftshift[\alpha]{i+1} & \text{if $i \le n-2$ and $\alpha_{i+2} > \alpha_i$}\\
	\leftshift[\alpha]{i+2} & \text{if $i \le n-2$ and $\alpha_{i+2} \le \alpha_i$}\\
	\leftshift[\alpha]{n} & otherwise\\
\end{cases}
\end{equation*}


See Fig. \ref{fig:permutations} for an example comparison of cool-lex and lexicographic order for two multisets.

This successor rule has the convenient property of ensuring that length of the successor's non-increasing prefix is easy to find.

In particular, if $\alpha_{i+2}$ is shifted, then the length of the non-increasing prefix is either 1 if $\alpha_{i+2}\le \alpha_1$ or $i+1$ otherwise. 

Similarly, if $\alpha_{i+1}$ is shifted, then the length of the non-increasing prefix is either 1 if $\alpha_{i+1}\le \alpha_1$ or $i+1$ otherwise. 


This property allows for a loopless implementation of the successor rule, as scanning the string to find the length of the non-increasing prefix is not required.  
A similar property regarding the length of successive non-increasing prefixes will allow for a loopless implementation of the shift Gray code for Lukasiewicz words in chapter \ref{chap:luka-implementation}.

Due to the simplicity and efficiency of this rule, it is used in the ``multicool" package in R, which is used for generating multiset permutations, Bell numbers, and other combinatorial objects \cite{multicool_2021}.   Further information on the package is available here: https://www.rdocumentation.org/packages/multicool/versions/0.1-12


\input{tikz_stairs_figure.tex}

